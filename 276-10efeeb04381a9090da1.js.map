{"version":3,"sources":["webpack:///./node_modules/prismjs/components/prism-naniscript.js"],"names":["Prism","expressionDef","params","pattern","alias","lookbehind","greedy","getTextContent","token","Array","isArray","map","join","content","languages","naniscript","inside","nani","hooks","add","env","tokens","forEach","type","input","stack","i","length","bracket","bracketsIndex","indexOf","push","pop","isBracketsBalanced"],"mappings":"kFAAA,EAAQ,QAER,EAAQ,QAER,EAAQ,QAER,SAAWA,GACT,IAAIC,EAAgB,qBAChBC,EAAS,CACX,gBAAiB,CACfC,QAAS,oBACTC,MAAO,YAET,mBAAoB,CAClBD,QAAS,WACTE,YAAY,EACZD,MAAO,YAET,sBAAuB,CAAC,CACtBD,QAASF,EACTG,MAAO,YACN,CACDD,QAAS,aACTE,YAAY,EACZC,QAAQ,EACRF,MAAO,YACN,CACDD,QAAS,cACTC,MAAO,cAwIX,SAASG,EAAeC,GACtB,MAAqB,iBAAVA,EACFA,EACEC,MAAMC,QAAQF,GAChBA,EAAMG,IAAIJ,GAAgBK,KAAK,IAE/BL,EAAeC,EAAMK,SA3IhCb,EAAMc,UAAUC,WAAa,CAE3B,QAAW,CACTZ,QAAS,gBACTE,YAAY,GAId,OAAU,CACRF,QAAS,QACTC,MAAO,MACPY,OAAQ,CACN,MAAS,CACPb,QAAS,gCACTE,YAAY,EACZD,MAAO,YAET,IAAO,CACLD,QAAS,UACTE,YAAY,KAKlB,MAAS,CACPF,QAAS,8BACTE,YAAY,EACZD,MAAO,SAET,QAAW,CACTD,QAAS,8BACTE,YAAY,EACZD,MAAO,WACPY,OAAQ,CACN,eAAgB,QAChB,WAAc,CACZb,QAASF,EACTK,QAAQ,EACRF,MAAO,YAET,iBAAkB,CAChBD,QAAS,mBACTa,OAAQd,KAKd,eAAgB,CACdC,QAAS,wBACTE,YAAY,EACZD,MAAO,cACPY,OAAQ,CAEN,eAAgB,cAChB,WAAc,CACZb,QAASF,EACTK,QAAQ,EACRF,MAAO,YAET,iBAAkB,CAChBD,QAAS,4BACTG,QAAQ,EACRF,MAAO,WACPY,OAAQ,CACN,iBAAkB,CAChBb,QAAS,iCACTE,YAAY,EACZW,OAAQd,GAEV,qBAAsB,CACpBC,QAAS,iBACTE,YAAY,EACZD,MAAO,QAET,kBAAmB,cAM7BJ,EAAMc,UAAUG,KAAOjB,EAAMc,UAAsB,WAQnDd,EAAMkB,MAAMC,IAAI,kBAAkB,SAAUC,GAE7BA,EAAIC,OACVC,SAAQ,SAAUd,GACvB,GAAqB,iBAAVA,GAAqC,iBAAfA,EAAMe,KAAyB,CAC9D,IAAIV,EAAUN,EAAeC,IAcnC,SAA4BgB,GAI1B,IAHA,IACIC,EAAQ,GAEHC,EAAI,EAAGA,EAAIF,EAAMG,OAAQD,IAAK,CACrC,IAAIE,EAAUJ,EAAME,GAChBG,EALS,OAKgBC,QAAQF,GAErC,IAAuB,IAAnBC,EACF,GAAIA,EAAgB,GAAM,EACxBJ,EAAMM,KAAKF,EAAgB,QACtB,GAAIJ,EAAMO,QAAUH,EACzB,OAAO,EAKb,OAAwB,IAAjBJ,EAAME,QA7BJM,CAAmBpB,KACtBL,EAAMe,KAAO,WACbf,EAAMK,QAAUA,UA1H1B,CAuKGb","file":"276-10efeeb04381a9090da1.js","sourcesContent":["require(\"core-js/modules/es6.array.map\");\n\nrequire(\"core-js/modules/es6.array.is-array\");\n\nrequire(\"core-js/modules/es6.array.for-each\");\n\n(function (Prism) {\n  var expressionDef = /\\{[^\\r\\n\\[\\]{}]*\\}/;\n  var params = {\n    'quoted-string': {\n      pattern: /\"(?:[^\"\\\\]|\\\\.)*\"/,\n      alias: 'operator'\n    },\n    'command-param-id': {\n      pattern: /(\\s)\\w+:/,\n      lookbehind: true,\n      alias: 'property'\n    },\n    'command-param-value': [{\n      pattern: expressionDef,\n      alias: 'selector'\n    }, {\n      pattern: /([\\t ])\\S+/,\n      lookbehind: true,\n      greedy: true,\n      alias: 'operator'\n    }, {\n      pattern: /\\S(?:.*\\S)?/,\n      alias: 'operator'\n    }]\n  };\n  Prism.languages.naniscript = {\n    // ; ...\n    'comment': {\n      pattern: /^([\\t ]*);.*/m,\n      lookbehind: true\n    },\n    // > ...\n    // Define is a control line starting with '>' followed by a word, a space and a text.\n    'define': {\n      pattern: /^>.+/m,\n      alias: 'tag',\n      inside: {\n        'value': {\n          pattern: /(^>\\w+[\\t ]+)(?!\\s)[^{}\\r\\n]+/,\n          lookbehind: true,\n          alias: 'operator'\n        },\n        'key': {\n          pattern: /(^>)\\w+/,\n          lookbehind: true\n        }\n      }\n    },\n    // # ...\n    'label': {\n      pattern: /^([\\t ]*)#[\\t ]*\\w+[\\t ]*$/m,\n      lookbehind: true,\n      alias: 'regex'\n    },\n    'command': {\n      pattern: /^([\\t ]*)@\\w+(?=[\\t ]|$).*/m,\n      lookbehind: true,\n      alias: 'function',\n      inside: {\n        'command-name': /^@\\w+/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'command-params': {\n          pattern: /[\\s\\S]*\\S[\\s\\S]*/,\n          inside: params\n        }\n      }\n    },\n    // Generic is any line that doesn't start with operators: ;>#@\n    'generic-text': {\n      pattern: /(^[ \\t]*)[^#@>;\\s].*/m,\n      lookbehind: true,\n      alias: 'punctuation',\n      inside: {\n        // \\{ ... \\} ... \\[ ... \\] ... \\\"\n        'escaped-char': /\\\\[{}\\[\\]\"]/,\n        'expression': {\n          pattern: expressionDef,\n          greedy: true,\n          alias: 'selector'\n        },\n        'inline-command': {\n          pattern: /\\[[\\t ]*\\w+[^\\r\\n\\[\\]]*\\]/,\n          greedy: true,\n          alias: 'function',\n          inside: {\n            'command-params': {\n              pattern: /(^\\[[\\t ]*\\w+\\b)[\\s\\S]+(?=\\]$)/,\n              lookbehind: true,\n              inside: params\n            },\n            'command-param-name': {\n              pattern: /^(\\[[\\t ]*)\\w+/,\n              lookbehind: true,\n              alias: 'name'\n            },\n            'start-stop-char': /[\\[\\]]/\n          }\n        }\n      }\n    }\n  };\n  Prism.languages.nani = Prism.languages['naniscript'];\n  /** @typedef {InstanceType<import(\"./prism-core\")[\"Token\"]>} Token */\n\n  /**\n   * This hook is used to validate generic-text tokens for balanced brackets.\n   * Mark token as bad-line when contains not balanced brackets: {},[]\n   */\n\n  Prism.hooks.add('after-tokenize', function (env) {\n    /** @type {(Token | string)[]} */\n    var tokens = env.tokens;\n    tokens.forEach(function (token) {\n      if (typeof token !== \"string\" && token.type === 'generic-text') {\n        var content = getTextContent(token);\n\n        if (!isBracketsBalanced(content)) {\n          token.type = 'bad-line';\n          token.content = content;\n        }\n      }\n    });\n  });\n  /**\n   * @param {string} input\n   * @returns {boolean}\n   */\n\n  function isBracketsBalanced(input) {\n    var brackets = \"[]{}\";\n    var stack = [];\n\n    for (var i = 0; i < input.length; i++) {\n      var bracket = input[i];\n      var bracketsIndex = brackets.indexOf(bracket);\n\n      if (bracketsIndex !== -1) {\n        if (bracketsIndex % 2 === 0) {\n          stack.push(bracketsIndex + 1);\n        } else if (stack.pop() !== bracketsIndex) {\n          return false;\n        }\n      }\n    }\n\n    return stack.length === 0;\n  }\n\n  ;\n  /**\n   * @param {string | Token | (string | Token)[]} token\n   * @returns {string}\n   */\n\n  function getTextContent(token) {\n    if (typeof token === 'string') {\n      return token;\n    } else if (Array.isArray(token)) {\n      return token.map(getTextContent).join('');\n    } else {\n      return getTextContent(token.content);\n    }\n  }\n})(Prism);"],"sourceRoot":""}