{"version":3,"sources":["webpack:///./node_modules/prismjs/components/prism-sml.js"],"names":["Prism","keywords","languages","sml","pattern","greedy","RegExp","source","replace","lookbehind","inside","alias","smlnj"],"mappings":"gFAAA,EAAQ,QAER,EAAQ,QAIR,SAAWA,GACT,IAAIC,EAAW,0PACfD,EAAME,UAAUC,IAAM,CAEpB,QAAW,4EACX,OAAU,CACRC,QAAS,sBACTC,QAAQ,GAEV,aAAc,CAAC,CAObD,QAASE,OAAO,2HAA2HC,OAAOC,QAAQ,eAAe,WACvK,MAAO,iBAAiBD,UACvBC,QAAQ,eAAe,WACxB,MAAO,6FAA6FD,UACnGC,QAAQ,cAAc,WACvB,MAAO,+BAA+BD,UACrCC,QAAQ,cAAc,WACvB,OAAOP,EAASM,UACd,KACJE,YAAY,EACZJ,QAAQ,EACRK,OAAQ,MAEP,CACDN,QAAS,yFACTK,YAAY,IAEd,SAAY,CACVL,QAAS,qCACTK,YAAY,GAEd,QAAWR,EACX,SAAY,CACVG,QAAS,oBACTK,YAAY,GAEd,OAAU,iDACV,KAAQ,CACNL,QAAS,2BACTO,MAAO,YAET,QAAW,sBACX,SAAY,4CACZ,YAAe,kBAEjBX,EAAME,UAAUC,IAAI,cAAc,GAAGO,OAASV,EAAME,UAAUC,IAC9DH,EAAME,UAAUU,MAAQZ,EAAME,UAAUC,IApD1C,CAqDGH","file":"390-2e5cfcffcdae70f42cc1.js","sourcesContent":["require(\"core-js/modules/es6.regexp.replace\");\n\nrequire(\"core-js/modules/es6.regexp.constructor\");\n\n// https://smlfamily.github.io/sml97-defn.pdf\n// https://people.mpi-sws.org/~rossberg/sml.html\n(function (Prism) {\n  var keywords = /\\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\\b/i;\n  Prism.languages.sml = {\n    // allow one level of nesting\n    'comment': /\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*)|\\(\\*(?:[^*(]|\\*(?!\\))|\\((?!\\*))*\\*\\))*\\*\\)/,\n    'string': {\n      pattern: /#?\"(?:[^\"\\\\]|\\\\.)*\"/,\n      greedy: true\n    },\n    'class-name': [{\n      // This is only an approximation since the real grammar is context-free\n      //\n      // Why the main loop so complex?\n      // The main loop is approximately the same as /(?:\\s*(?:[*,]|->)\\s*<TERMINAL>)*/ which is, obviously, a lot\n      // simpler. The difference is that if a comma is the last iteration of the loop, then the terminal must be\n      // followed by a long identifier.\n      pattern: RegExp(/((?:^|[^:]):\\s*)<TERMINAL>(?:\\s*(?:(?:\\*|->)\\s*<TERMINAL>|,\\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\\s+<LONG-ID>)))*/.source.replace(/<NOT-LAST>/g, function () {\n        return /\\s*(?:[*,]|->)/.source;\n      }).replace(/<TERMINAL>/g, function () {\n        return /(?:'[\\w']*|<LONG-ID>|\\((?:[^()]|\\([^()]*\\))*\\)|\\{(?:[^{}]|\\{[^{}]*\\})*\\})(?:\\s+<LONG-ID>)*/.source;\n      }).replace(/<LONG-ID>/g, function () {\n        return /(?!<KEYWORD>)[a-z\\d_][\\w'.]*/.source;\n      }).replace(/<KEYWORD>/g, function () {\n        return keywords.source;\n      }), 'i'),\n      lookbehind: true,\n      greedy: true,\n      inside: null // see below\n\n    }, {\n      pattern: /((?:^|[^\\w'])(?:datatype|exception|functor|signature|structure|type)\\s+)[a-z_][\\w'.]*/i,\n      lookbehind: true\n    }],\n    'function': {\n      pattern: /((?:^|[^\\w'])fun\\s+)[a-z_][\\w'.]*/i,\n      lookbehind: true\n    },\n    'keyword': keywords,\n    'variable': {\n      pattern: /(^|[^\\w'])'[\\w']*/,\n      lookbehind: true\n    },\n    'number': /~?\\b(?:\\d+(?:\\.\\d+)?(?:e~?\\d+)?|0x[\\da-f]+)\\b/i,\n    'word': {\n      pattern: /\\b0w(?:\\d+|x[\\da-f]+)\\b/i,\n      alias: 'constant'\n    },\n    'boolean': /\\b(?:false|true)\\b/i,\n    'operator': /\\.\\.\\.|:[>=:]|=>?|->|[<>]=?|[!+\\-*/^#|@~]/,\n    'punctuation': /[(){}\\[\\].:,;]/\n  };\n  Prism.languages.sml['class-name'][0].inside = Prism.languages.sml;\n  Prism.languages.smlnj = Prism.languages.sml;\n})(Prism);"],"sourceRoot":""}